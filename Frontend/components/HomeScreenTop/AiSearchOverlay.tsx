// AISearchOverlay.tsx - Enhanced with better UX
import React, { useState, useEffect, useRef, useCallback } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  Animated,
  Dimensions,
  TextInput,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import tw from 'twrnc';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

interface AISuggestion {
  id: string;
  text: string;
  category?: string;
  reasoning?: string;
  priority?: string;
}

interface AISearchOverlayProps {
  visible: boolean;
  onClose: () => void;
  onSearchUpdate: (newSearch: string) => void;
  currentSearch: string;
  searchContext?: {
    location?: string;
    dates?: {
      checkin: string;
      checkout: string;
    };
    guests?: {
      adults: number;
      children: number;
    };
    budget?: {
      min?: number;
      max?: number;
      currency?: string;
    };
  };
}

const BASE_URL = 'http://localhost:3003';

const AISearchOverlay: React.FC<AISearchOverlayProps> = ({
  visible,
  onClose,
  onSearchUpdate,
  currentSearch,
  searchContext,
}) => {
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(screenHeight)).current;
  
  const [searchText, setSearchText] = useState(currentSearch);
  const [suggestions, setSuggestions] = useState<AISuggestion[]>([]);
  const [usedSuggestions, setUsedSuggestions] = useState<Set<string>>(new Set());
  const [originalSearch, setOriginalSearch] = useState('');
  const [isListening, setIsListening] = useState(false);
  const [isVisible, setIsVisible] = useState(visible);
  const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(false);
  const [suggestionsError, setSuggestionsError] = useState<string | null>(null);

  // Animated values for loading dots
  const dot1Anim = useRef(new Animated.Value(0)).current;
  const dot2Anim = useRef(new Animated.Value(0)).current;
  const dot3Anim = useRef(new Animated.Value(0)).current;

  // Animated loading dots effect
  useEffect(() => {
    if (isLoadingSuggestions) {
      const animateDot = (dotAnim: Animated.Value, delay: number) => {
        return Animated.loop(
          Animated.sequence([
            Animated.timing(dotAnim, {
              toValue: 1,
              duration: 600,
              delay,
              useNativeDriver: true,
            }),
            Animated.timing(dotAnim, {
              toValue: 0,
              duration: 600,
              useNativeDriver: true,
            }),
          ])
        );
      };

      const animation = Animated.parallel([
        animateDot(dot1Anim, 0),
        animateDot(dot2Anim, 200),
        animateDot(dot3Anim, 400),
      ]);

      animation.start();

      return () => {
        animation.stop();
        dot1Anim.setValue(0);
        dot2Anim.setValue(0);
        dot3Anim.setValue(0);
      };
    }
  }, [isLoadingSuggestions, dot1Anim, dot2Anim, dot3Anim]);

  // Fetch AI suggestions from backend
  const fetchAISuggestions = useCallback(async (searchQuery: string) => {
    try {
      setIsLoadingSuggestions(true);
      setSuggestionsError(null);
      
      console.log('🤖 Fetching AI suggestions for:', searchQuery);

      const response = await fetch(`${BASE_URL}/api/hotels/ai-suggestions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          currentSearch: searchQuery,
          searchContext: searchContext
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (data.success && data.suggestions) {
        console.log(`✅ Received ${data.suggestions.length} AI suggestions`);
        setSuggestions(data.suggestions);
        
        // Log model used for debugging
        if (data.metadata?.model) {
          console.log(`🤖 Suggestions generated by: ${data.metadata.model}`);
        }
      } else {
        throw new Error('Invalid response format');
      }

    } catch (error: any) {
      console.error('❌ Failed to fetch AI suggestions:', error);
      setSuggestionsError(error.message);
      
      // Fallback to basic suggestions
      const fallbackSuggestions = generateFallbackSuggestions(searchQuery);
      setSuggestions(fallbackSuggestions);
    } finally {
      setIsLoadingSuggestions(false);
    }
  }, [searchContext]);

  // Generate fallback suggestions (same as before but with new interface)
  const generateFallbackSuggestions = useCallback((searchQuery: string): AISuggestion[] => {
    const query = searchQuery.toLowerCase();
    const suggestionTexts: string[] = [];

    // Budget suggestions
    if (!query.includes('$') && !query.includes('budget')) {
      suggestionTexts.push('under $150 per night', 'under $300 per night');
    }

    // Guest count
    if (!query.includes('people') && !query.includes('guest')) {
      suggestionTexts.push('for 2 people', 'for 4+ people');
    }

    // Location based
    if (query.includes('beach')) {
      suggestionTexts.push('with ocean view', 'walking distance to beach');
    } else if (query.includes('city') || query.includes('downtown')) {
      suggestionTexts.push('in walkable area', 'near public transport');
    } else {
      suggestionTexts.push('in city center', 'in quiet area');
    }

    // Amenities
    if (!query.includes('wifi') && !query.includes('breakfast')) {
      suggestionTexts.push('with free WiFi', 'with free breakfast');
    }
    
    if (!query.includes('pool') && !query.includes('parking')) {
      suggestionTexts.push('with pool access', 'with free parking');
    }

    // Quality
    if (!query.includes('rating') && !query.includes('star')) {
      suggestionTexts.push('with 4+ star rating', 'with recent positive reviews');
    }

    // Flexibility
    if (!query.includes('cancel')) {
      suggestionTexts.push('with free cancellation');
    }

    // Default suggestions for empty search
    if (!query.trim()) {
      const defaultTexts = [
        'under $200 per night',
        'for 2 people', 
        'with free WiFi',
        'in city center',
        'with 4+ star rating',
        'with free breakfast'
      ];
      
      return defaultTexts.map((text, index) => ({
        id: `fallback-${index}`,
        text,
        category: 'general',
        priority: 'medium'
      }));
    }

    // Take first 6 unique suggestions
    const uniqueTexts = [...new Set(suggestionTexts)].slice(0, 6);
    
    return uniqueTexts.map((text, index) => ({
      id: `fallback-${index}-${Date.now()}`,
      text,
      category: 'general',
      priority: 'medium'
    }));
  }, []);

  // Fetch suggestions when overlay opens or when we have context changes
  useEffect(() => {
    if (visible) {
      // Don't fetch suggestions on every keystroke, only when overlay opens
      fetchAISuggestions(currentSearch);
    }
  }, [visible, fetchAISuggestions]);

  // Track if user is manually typing (not selecting suggestions)
  const [isManualTyping, setIsManualTyping] = useState(false);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Optional: Fetch new suggestions when search text changes (debounced) - only for manual typing
  useEffect(() => {
    if (visible && searchText !== currentSearch && isManualTyping) {
      const timeoutId = setTimeout(() => {
        fetchAISuggestions(searchText);
        setIsManualTyping(false); // Reset after fetching
      }, 1000); // 1 second debounce for user typing

      return () => clearTimeout(timeoutId);
    }
  }, [searchText, currentSearch, visible, isManualTyping, fetchAISuggestions]);

  // Reset when overlay opens
  useEffect(() => {
    if (visible) {
      setOriginalSearch(currentSearch);
      setSearchText(currentSearch);
      setUsedSuggestions(new Set()); // Reset used suggestions
      setIsManualTyping(false); // Reset manual typing flag
      
      // Clear any pending timeouts
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
    }
  }, [visible, currentSearch]);

  // Handle visibility animations
  useEffect(() => {
    if (visible) {
      setIsVisible(true);
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.spring(slideAnim, {
          toValue: 0,
          tension: 80,
          friction: 8,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.spring(slideAnim, {
          toValue: screenHeight,
          tension: 100,
          friction: 8,
          useNativeDriver: true,
        }),
      ]).start(({ finished }) => {
        if (finished) {
          setIsVisible(false);
        }
      });
    }
  }, [visible, fadeAnim, slideAnim]);

  const handleSearchTextChange = useCallback((text: string) => {
    setSearchText(text);
    
    // Mark as manual typing to trigger suggestion refresh
    setIsManualTyping(true);
    
    // Clear any existing timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    
    // Set a new timeout to reset manual typing flag if user stops typing
    typingTimeoutRef.current = setTimeout(() => {
      setIsManualTyping(false);
    }, 2000);
  }, []);

  const handleSuggestionSelect = useCallback((suggestion: AISuggestion) => {
    const updatedSearch = searchText.trim() 
      ? `${searchText} ${suggestion.text}`
      : suggestion.text;
    
    // Update search text without triggering manual typing flag
    setSearchText(updatedSearch);
    
    // Mark this suggestion as used so it disappears
    setUsedSuggestions(prev => new Set(prev).add(suggestion.id));
    
    // Ensure manual typing flag is false to prevent suggestion reload
    setIsManualTyping(false);
    
    // Clear any pending typing timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
  }, [searchText]);

  const handleApply = useCallback(() => {
    onSearchUpdate(searchText);
    onClose();
  }, [searchText, onSearchUpdate, onClose]);

  const handleCancel = useCallback(() => {
    setSearchText(originalSearch);
    onClose();
  }, [originalSearch, onClose]);

  const handleMicrophonePress = useCallback(() => {
    if (isListening) {
      setIsListening(false);
    } else {
      setIsListening(true);
      setTimeout(() => {
        setIsListening(false);
      }, 3000);
    }
  }, [isListening]);

  // Get category icon
  const getCategoryIcon = (category?: string): keyof typeof Ionicons.glyphMap => {
    switch (category) {
      case 'budget': return 'card-outline';
      case 'amenities': return 'wifi-outline';
      case 'location': return 'location-outline';
      case 'experience': return 'star-outline';
      case 'property-type': return 'business-outline';
      case 'guest-needs': return 'people-outline';
      default: return 'add';
    }
  };

  // Get priority color
  const getPriorityColor = (priority?: string): string => {
    switch (priority) {
      case 'high': return '#10B981'; // green
      case 'medium': return '#F59E0B'; // amber
      case 'low': return '#6B7280'; // gray
      default: return '#6B7280';
    }
  };

  // Filter out used suggestions
  const availableSuggestions = suggestions.filter(suggestion => !usedSuggestions.has(suggestion.id));

  // Enhanced loading component
  const LoadingComponent = () => (
    <View style={tw`flex-row items-center justify-center py-8`}>
      <View style={tw`flex-row items-center bg-gray-50 px-4 py-3 rounded-full border border-gray-200`}>
        <View style={tw`flex-row items-center mr-3`}>
          <Animated.View
            style={[
              tw`w-2 h-2 rounded-full bg-gray-500 mr-1`,
              {
                opacity: dot1Anim,
                transform: [{
                  scale: dot1Anim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.8, 1.2],
                  }),
                }],
              },
            ]}
          />
          <Animated.View
            style={[
              tw`w-2 h-2 rounded-full bg-gray-500 mr-1`,
              {
                opacity: dot2Anim,
                transform: [{
                  scale: dot2Anim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.8, 1.2],
                  }),
                }],
              },
            ]}
          />
          <Animated.View
            style={[
              tw`w-2 h-2 rounded-full bg-gray-500`,
              {
                opacity: dot3Anim,
                transform: [{
                  scale: dot3Anim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.8, 1.2],
                  }),
                }],
              },
            ]}
          />
        </View>
        <Text style={tw`text-sm font-medium text-gray-700`}>
          AI is crafting suggestions...
        </Text>
        <Ionicons name="sparkles" size={16} color="#3B82F6" style={tw`ml-2`} />
      </View>
    </View>
  );

  if (!isVisible) {
    return null;
  }

  return (
    <View style={tw`absolute inset-0 z-50`}>
      {/* Backdrop */}
      <Animated.View
        style={[
          tw`absolute inset-0 bg-black/60`,
          { opacity: fadeAnim }
        ]}
      >
        <TouchableOpacity
          style={tw`flex-1`}
          onPress={handleCancel}
          activeOpacity={1}
        />
      </Animated.View>

      {/* Overlay Content */}
      <Animated.View
        style={[
          tw`absolute inset-0 justify-end`,
          { transform: [{ translateY: slideAnim }] }
        ]}
      >
        <View style={[tw`bg-white px-6 pt-8 pb-6 rounded-t-3xl`, { height: screenHeight * 0.65 }]}>
          
          {/* Fixed Header */}
          <View style={tw`items-center mb-6`}>
            <Text style={tw`text-xl font-bold text-gray-900`}>
              Refine Your Search
            </Text>
          </View>

          {/* Scrollable Content */}
          <ScrollView 
            style={tw`flex-1`}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            {/* Search Box */}
            <View style={tw`bg-gray-50 rounded-xl border border-gray-200 mb-4`}>
              <View style={tw`p-4`}>
                <Text style={tw`text-xs text-gray-600 mb-3`}>Current Search:</Text>
                <View style={tw`flex-row`}>
                  <View style={tw`w-7 pt-1`}>
                    <Ionicons
                      name="search"
                      size={16}
                      color="#9CA3AF"
                    />
                  </View>
                  <View style={tw`flex-1`}>
                    <TextInput
                      style={[
                        tw`text-sm text-gray-900 font-medium`,
                        { 
                          lineHeight: 20, 
                          paddingVertical: 0, 
                          minHeight: 20,
                          maxHeight: 120, // Limit to about 6 lines
                          textAlignVertical: 'top'
                        }
                      ]}
                      value={searchText}
                      onChangeText={handleSearchTextChange}
                      placeholder="Enter your search criteria..."
                      placeholderTextColor="#9CA3AF"
                      multiline={true}
                      scrollEnabled={false} // Disable internal scrolling
                      returnKeyType="done"
                      blurOnSubmit={true}
                    />
                  </View>
                  <View style={tw`w-8 pt-1 items-center`}>
                    {searchText.length > 0 && (
                      <TouchableOpacity
                        onPress={() => handleSearchTextChange('')}
                        style={tw`p-1`}
                        activeOpacity={0.7}
                      >
                        <Ionicons
                          name="close-circle"
                          size={16}
                          color="#9CA3AF"
                        />
                      </TouchableOpacity>
                    )}
                  </View>
                </View>
              </View>
            </View>

            {/* Voice Input Button */}
            <View style={tw`items-center mb-8`}>
              <TouchableOpacity
                style={[
                  tw`w-16 h-16 rounded-full items-center justify-center border-2`,
                  isListening 
                    ? tw`bg-red-500 border-red-500` 
                    : tw`bg-gray-50 border-gray-300`
                ]}
                onPress={handleMicrophonePress}
                activeOpacity={0.7}
              >
                <Ionicons
                  name={isListening ? "stop" : "mic"}
                  size={24}
                  color={isListening ? "white" : "#666666"}
                />
              </TouchableOpacity>
              
              {isListening && (
                <Text style={tw`text-sm text-red-500 font-medium mt-2`}>
                  Listening...
                </Text>
              )}
            </View>

            {/* AI Suggestions */}
            <View style={tw`mb-8`}>
              <View style={tw`flex-row items-center justify-between mb-4`}>
                <View style={tw`flex-row items-center`}>
                  <Text style={tw`text-sm font-semibold text-gray-900 mr-2`}>
                    AI Suggestions
                  </Text>
                  <Ionicons name="sparkles" size={14} color="#666666" />
                </View>
              </View>
              
              {/* Enhanced Loading State */}
              {isLoadingSuggestions && <LoadingComponent />}
              
              {/* Error State */}
              {suggestionsError && !isLoadingSuggestions && (
                <View style={tw`mb-3 p-3 bg-amber-50 rounded-lg border border-amber-200`}>
                  <Text style={tw`text-xs text-amber-700`}>
                    ⚠️ Using fallback suggestions (AI unavailable)
                  </Text>
                </View>
              )}
              
              {/* Suggestions Grid */}
              {!isLoadingSuggestions && (
                <View style={tw`flex-row flex-wrap gap-2`}>
                  {availableSuggestions.map((suggestion) => (
                    <TouchableOpacity
                      key={suggestion.id}
                      style={tw`flex-row items-center px-3 py-2 rounded-full border bg-gray-50 border-gray-300`}
                      onPress={() => handleSuggestionSelect(suggestion)}
                      activeOpacity={0.7}
                    >
                      <View style={tw`flex-row items-center flex-1`}>
                        <Ionicons
                          name={getCategoryIcon(suggestion.category)}
                          size={12}
                          color={getPriorityColor(suggestion.priority)}
                          style={tw`mr-1`}
                        />
                        <Text style={tw`text-xs font-medium text-gray-700 mr-1`}>
                          {suggestion.text}
                        </Text>
                        <Ionicons
                          name="add"
                          size={12}
                          color="#666666"
                        />
                      </View>
                    </TouchableOpacity>
                  ))}
                </View>
              )}
              
              {/* Empty State */}
              {availableSuggestions.length === 0 && !isLoadingSuggestions && (
                <View style={tw`py-8 items-center`}>
                  <Ionicons name="checkmark-circle" size={24} color="#10B981" />
                  <Text style={tw`text-sm text-gray-500 mt-2`}>
                    All suggestions applied!
                  </Text>
                </View>
              )}
            </View>

            {/* Add some bottom padding for scroll */}
            <View style={tw`h-20`} />
          </ScrollView>

          {/* Bottom Actions - Fixed at bottom */}
          <View style={tw`mt-6 gap-4 border-t border-gray-100 pt-6`}>
            <View style={tw`flex-row gap-4`}>
              <TouchableOpacity
                style={tw`flex-1 py-4 px-6 rounded-xl border-2 border-gray-200 bg-white`}
                onPress={handleCancel}
                activeOpacity={0.7}
              >
                <Text style={tw`text-center text-sm font-semibold text-gray-700`}>
                  Cancel
                </Text>
              </TouchableOpacity>
              
              <TouchableOpacity
                style={tw`flex-1 py-4 px-6 rounded-xl bg-black`}
                onPress={handleApply}
                activeOpacity={0.8}
              >
                <Text style={tw`text-center text-sm font-semibold text-white`}>
                  Apply Search
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Animated.View>
    </View>
  );
};

export default AISearchOverlay;